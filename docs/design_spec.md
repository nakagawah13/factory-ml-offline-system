# 設計仕様書

## 1. システム概要

本プロジェクトは、工場内のオフライン環境で稼働する構造化データを用いた機械学習システムです。エンジニアは管理用GUIアプリを操作し、推論、シミュレーション、モデル再学習、劣化診断を行います。

## 2. アーキテクチャ特徴

- **完全オフライン:** インターネット接続不可。
- **ハイブリッド構成:**
  - **GUI / 推論 / シミュレーション:** Java (ONNX Runtimeによる高速処理)
  - **学習 / 分析 / ドリフト検知:** Python (Subprocessによるバッチ処理)

## 3. 技術スタック & 環境

- **ハードウェア:** Intel Core i7/i5 (12th Gen), 16GB RAM, Windows OS
- **GUIアプリ (Main):**
  - Language: Java 11+
  - Library: Microsoft ONNX Runtime (Java API)
  - Framework: JavaFX 11 (推奨) または Swing
  - JSON Lib: Jackson or Gson
  - Components: WebView (HTMLレポート表示用), Charts
- **学習ツール (Sub):**
  - Language: Python 3.10+ (PyInstallerでexe化)
  - Libraries: scikit-learn, pandas, skl2onnx, onnxruntime, shap, evidently (ドリフト検知), dtreeviz (可視化)

## 4. データフローと責任分界点

JavaアプリとONNXモデルの間で、前処理の役割を厳格に分担します。

| 処理フェーズ | 担当 | 詳細 |
| :--- | :--- | :--- |
| **1. ファイル読込 & Validation** | Java | CSV/Excel読み込み。`schema.json` に基づく型チェック。 |
| **2. バリデーション** | Java | `schema.json` に基づく列名・型チェック。 |
| **3. 日付解析** | Java | 文字列の日付を「年」「月」「日」などの数値に分解。 |
| **4. Tensor作成** | Java | データを数値群と文字列群の2つのTensorにパッキング。 |
| **5. 前処理(Scaling)** | ONNX | 数値データの正規化・標準化。 |
| **6. 前処理(Encode)** | ONNX | カテゴリデータの数値化。 |
| **7. 推論/予測** | ONNX | モデルコアロジックによる計算。 |
| **8. 高度分析(XAI/Drift)** | Python | 学習時に静的なHTML/JSONレポートを生成。 |
| **9. シミュレーション(What-If)** | Java | メモリ上のTensor値を書き換えてONNXを再実行。 |

## 5. UIフロー設計と新機能 (v3.0 Features)

画面は「タブ切り替え式」とし、**[推論タブ]** と **[学習タブ]** を設けます。

### 5.1. 推論タブ

1. **[Load Data] ボタン:** ファイルチューザーを開き、CSV/Excelを選択。
2. **バリデーション実行 (自動):** 成功時はデータプレビューを表示し、「推論実行」ボタンを活性化。
3. **[Run Inference] ボタン:** 確信度が閾値内にある行をハイライト表示。
4. **[Simulation] ボタン:** What-Ifシミュレーターウィンドウを開く。

### 5.2. 学習タブ

1. **[Select Training Data] ボタン:** 過去の蓄積データを選択。
2. **[Validate Schema] ボタン:** データの列構成を確認。
3. **[Start Training] ボタン:** Pythonサブプロセスを起動し、分析レポートを生成。

## 6. モデル管理とバージョニング

モデルファイル単体ではなく、「モデル + 分析レポート群」をセットで管理します。

### 6.1. ファイル保存ルール

- **保存先:** `/models/archive/`
- **フォルダ名:** `model_YYYYMMDD_HHmm`

### 6.2. アクティブモデルの切り替え

アプリ設定ファイル内で、現在使用中のモデルパスを保持します。

## 7. 設定ファイル構造 (Schema Definition)

バリデーションロジックの要となる `schema.json` の構造定義を行います。

## 8. プロセス間通信とエラーハンドリング

JavaとPython間の通信とエラーハンドリング要件を定義します。

## 9. コンポーネント詳細設計 (Class Design)

JavaアプリケーションとPython学習ツールのクラス設計を行います。

## 10. 追加で検討すべき機能

- 類似・参考データ検索機能
- アノテーション・フィードバック機能
- モデル変更履歴＆ロールバック機能

## 11. まとめ

本プロジェクトは、工場内のオフライン環境での機械学習システムを構築することを目的としています。各機能は、エンジニアが効率的にデータを扱い、モデルを管理できるように設計されています。